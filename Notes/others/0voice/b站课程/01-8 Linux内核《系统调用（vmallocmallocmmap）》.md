首先欢迎各位朋友来到铃声教育
我是威克
接下来我们主要是学习这个LINUX内核里面的
一个物理和虚拟内存的管理
那么通过这第一幅图和第二幅图
我们就了解这个什么LINUX内核啊
空间所分为的各个模块
那我们这个课程呢主要研究的是进程调度
还有这个网络协议栈
设备驱动程序
文件系统和内存管理
还有其他的附属模块
那么这节课呢我们主要是学习什么呢
第一个是系统调用
第二个呢是虚拟内存对应的一个什么进程
地址空间
第三个是页面回收与缺页异常
第四个是内存规则以及页面的迁移
那么首先我们来看第一个
那我们在研发过程当中
嗯还有什么呢
还有VMACC这些相关的函数
那么这三个函数啊
这三个函数就是这个它是什么呢
是常用的一个常用的一个接口函数
非常啊
但是这三个之间是非常的相似
但是实际上大家也可以进行进一步的研究
那首先我们看第一个讲一个比较常用的
比如KMCKMC这个函数呢
它是基于什么
它是基于内部的一个什么快的一个什么分配器
但是我们都知道这个slab的一个什么呢
它的一个缓冲区啊
它是建立在什么
建立在一个建立在一个物理地址啊
嗯物理地址连续的一个什么呢
啊大的一个什么内存块上面
对不对
就这个意思
所以说他的一个什么
所以说他的一个缓存缓存对象啊
他也是一个什么呢
物理地址连续的就这么个意思
但是我们知道
如果啊如果在内核当中不连续的一个物理地址
而且呢它仅仅是什么呢
仅仅需要这个什么内核空间的一个虚拟地址
是连续的内存块就可以了
那么就是说这个时候我们就可以使用什么
使用这个VMACO进行进一步操作
在内核源码里面
我们可以知道你看他怎么声明啊
大家看看第二个吧
第二个是什么
是V
打开这边在这个内核源码里面找到这个mm看好
那么在mm里面呢
它有一个什么呢
有个VMACO
就这么一个看看就行
那么现在我们所看到的就是他的看到没有
它那个定时就要搞清楚啊
啊先调用它是不是
然后再往这边进行进一步执行
没有两个下划线
没有一个n u m a n node是不是
但是要注意了啊
这个VMACO这个内核源码分析设计的时候
它的架构就是这样子的
所以我们搞清楚这是第一个在这里
那么现在的话我们就回到这来是吧
什么意思呢
v ml函数的声明啊
具体的这个什么内核的页码如下
就这一块
但是我们知道一般是什么呢
比如你从4.0的版本或者是4.12
是不是
但是要知道一点
就是如果是5.0要注意啊
它在什么呢
他直接使用什么
就这个函数它使用什么
使用的这个分配的一个掩码分配
这个掩码分配掩码是什么呢
就是它是一个GFP下划线
可是这个但是如果是对
这个是基于什么呢
这是5.0的内核
那如果是4.0
还有一个参数
如果4.0它还有一个参数啊
这个我们也得研究一下是吧
OK这并不是什么呢
这并不是说明他不再使用什么高端内存
就这个意思
那当我们在调的过程当中
你看啊
再往后面你就可以往后面深入的进行进一步
你看还有一个
还有一个刚才我们这边还有一个叫做什么
他有两个下划线就出来了没有
就这一块
来看加C是吧
那你看第一个函数里面包含什么size gf
还有什么
它总共分为什么
总定调那个函数它总共分为什么分为三个参数
是不是三个参数啊
那么这三个参数在内核里面
它分别是用来干什么的啊
它功能是做什么
这一点我们要搞清楚啊
好那接下来我们这就出来了是吧
你比如第一个GFP下划线mask
那么这个成员就是这个参数啊
这个参数这个参数它是什么
它是我们这个页面分配器使用的一个什么
分配源码
这是第一个吧
第二个是size size
就是你分配内存的大小
第三个
那第三个是什么呢
就是pro这个参数
这个参数就是你分配内存的一个什么属性啊
就这么简单
那么我们有一个什么
比如下划线
你看两个下划线V接口是分配内存
这样做的好处是指定什么
直接指定gf p mask的码
是不是这个页码后面可以进行进一步的研究
大家可以看一下
是不是那么了解一些什么呢
他一般都是这样做的啊
你可以在驱动块里面可以找到这个什么
找到对应的一些相关词进行进一步来完成
他就这么一回事
那么we ma这个实现的函数核心你要搞清楚啊
要注意了
你看其实他就是上面对那个问题
你看啊怎么做呢
好我们CTRLF我们看这个内核源码
内核源码里面有个什么
有一个下划线
你看他有个VMC下划线
有什么node
下方是一个什么range
就这么一个真正的核心
就一定要注意CTRLC是吧
它的一个真正真正节点的时候
它就跳到这来
跳到这来
看他这个node下面是不是就是我们即将要设计的
就是这个调用的时候
他这么一回事
他怎么做呢
你看啊在这个地方
其实这个VMVMC这个函数它的一个核心实现
对不对
它的核心实现主要是什么
在调用内核里面专门用来用用
就等一下啊
这样不行是吧
那下划线自己写V
下划线node里面什么range
这个函数来实现实操作是吧
具体如下啊
OK那我就从这地方跳到这来
嗯这个问题解决了
就说内存之间实现了一个关系啊
核心点击这个函数
你看这个函数出来
但是这个函数出来之后呢
我们有一个什么啊
当我们调用这个函数的时候
你看到这个的时候
他有什么
看VMVMVMELOCK
Start v mend
其实这两个它只是一个非常重要的红
对不对
这个红的设计它在哪个地方呢
你看啊这个行业设计它是这样的
嗯给大家找到这个设计在对P7table里面来好
我们看内核源码
注意啊
在这个
逻辑啊
ARCH下面的arm64
include include里面什么SMS里面应该是一个memory
看到没有
先找
先找到memory啊
双击memory
双击之后
嗯这个这个里面下面有一个没有一个什么
来个v ma start和v ma and这两个是一个红
要注意啊
这两个红非常重要
其实它跟什么跟我们这个memory的地方是非常相似
现在我们来看啊
他就这么个结构
所以说这个地方就
这两个这两个结果是这两个结果所对应的
这两个是属于这块的
看他的野马设计
野马设计的架构是这样
是不是
你看这它是什么呢
就讲了一个V
下划线有什么
and它是什么
它是我们为数
we will lock这个函数当中
函数当中什么最重要的一个什么红
对不对
那么这个红刚才看到了里面有一个什么
有一个叫做
你看models下划线是不是它是什么意思
那么在设计的过程当中
这个v medical start它是一个什么
它是我们这个VMACA这个函数啊
就是这块区域了
它就是v mo这块区域它的一个什么呢开始
但是它是以什么
是以内核模块这个区域的一个什么结束地址
作为标准啊
作为一个起始点
那么他的这个起始点结束地址在哪里呢
就是个model是不是就这个地方啊
他这个为标准的
就是MMODELES下划线什么的
它是以这个为标准为标准的话
在内核里面
啊这个地方看到没有
就这个它的定义在这里
你要搞清楚这一点啊
好那么这个问题我们就搞定了是吧
好那么现在我们解决这个问题之后是吧
那后面我们再进行进一步研究
什么意思呢
就是相当刚刚我们所讲的这个函数
看到没有啊
就这个你看啊
这个掩码分析
我们可以对它进行进一步来设计啊
什么意思呢
你这个VMACLE这个start
他的红就是零
XFF这个地址是不是
and就是FFF后面四个零是吧
那么整个VMC大小是可以达到达到多少T
那么可以自行自行进行进一步的计算
那么在设计的过程当中
在内核源码它的一个分析有这么几个
你看啊嗯我们在memory里面
那我们就找到什么呀
我们所想要的这个下划线
两个下划线呢
这个什么VMLOCK
你看啊
你跑哪去了
we mo看啊
别着急嗯
找到它
你点这个函数
注意啊
点那个函数
点一下
点一下之后
我们会发现你没有size
The lag
是不是这这这些相关操作啊
那么分别是做什么
现在我们一个一个来研究
针对这个内核源码啊
你这个分配内存是这样的
他总共一个两个
三个四个五个六个七个八个九个
总共是九个参数啊
这九个参数都告诉我们了
你看第一个size
它那个里面看这个size是什么意思
来记log allocation
这个size是什么
就是相当于你第一个参数
你这里面的D的参数就相当于是什么呢
相当于我们这个VMACY
这个函数所分配的一个什么内存大小
好后面有个lag
你看他第二个参数
第二个参数是什么
就是对齐内存对齐的一个要求操作
再往下面有一个什么start
那个start看v m l r start对应的是什么呢
对应的是V为什么呢
为MC区域的一个什么起始地址
下面这个同样的道理
就是v ma区域的一个什么结束地址
就这么简单啊
再往下面有个什么g f p mask
GFP下划线mask就是刚刚提到了
它是一个什么呢
它是一个页面分配器的一个什么分配的
一个掩码
非常重要
再往下面有个pp那个pro是什么意思呢
就是我们分配这个参数
就是你就是我们分配的一个什么
来分配物理页面
分配物理页面
它所对应的一个什么对应的一个内存属性
接着后面有个什么有个node node是什么node
就是这个标志了
哎就是v Mac他这个区域这个区域的一个标志位
是不是不是我vm flag啊
没错没错
就是它标志位在后面有一个什么
后面这个node没有node l那这个node是代表什么node
它这个参数
它就是我们所讲内存的一个什么节点
看最后一个你看color britain address
它就是相当于什么
相当于调用者的一个返回第一次操作
那么整体核心我们就全部给他讲完了
是不是
就是你调这个函数来分配这个空间的时候
他就会传出总共有九个参数啊
就进来了
好九个参数进来之后呢
那现在我们首先来看第一个
第一个
那么第一个是什么呢
你看啊
第一个你看它就往下执行
首先它定一个什么v m l structure
这是什么
这是虚拟内存的
就是虚拟内存的一个结构体
你看size size里面什么page lag
再判断这是一那么其实他为什么这么做呢
这样做这样做他就有这样做的理由啊
这样做就这样做
理由就是针对这个地方
这地方
那么做什么呢
他是这样的
相当于什么
相当于就是我们调用这个什么系统为MC
这个函数来分配什么
分配大小
他说要要以什么呢
要以页面要以页面大小进行对齐嗯
就是你执行这个地方是不是就执行了啊
要注意了
但是他有一个点是什么问题呢
就是说如果这个VMACO
它要求分配大小为十个字节
那怎么办
对不对
如果它分成十个字节
那么V还还会分配一个页面
那么剩下什么
你四零
比如4096
是不是十个字节他就浪费了
是不是还是对
就按照这个要求啊
你看他这个分配过程当中
他这么回事
假设是吧
假设啊
假设什么呢
假设你这个函数V嗯
VMACA这个函数是吧
你配什么
假设我们要为多少要十个字节嗯
你分配十个字节的话
那要注意啊
所以你这个属于系统的系统操作的时候
他就会为什么就为我们这个VMACO这个函数嗯
还会什么
他不是给你分配十个字节
它还会分配一个什么
分配一个页面
是不是分配个页面
那么剩下的注意啊
就是你剩下一个页面就是什么
就相当于两个两个
是不是那个页面的话就相当于41024×4
是不是就4096是吧
那就4096的话
你4096-30
那么现在就剩下什么
剩下44086
4086
剩下4086这个字节
他就造成一个什么造成浪费是不好
另外呢另外要分配的内存大小
你不能不能为零
或者你不能不能大于系统所有的内存
这就是说为什么要通过这个size
好那么这个处理完之后
接着接着下面来看
等下来了啊
这就判断是不是下面就有个get vml node
这个调这个函数
是不是调那个函数的话呢
其实再往下面他就确保什么
它确保我们当前不处于中断上下文切换
VIMEO这个函数在分配过程当中
他可能会睡眠
就是说你进程在中断上下文当中
睡眠不是一个非常好的一个操作
是不是这是一个还有一个什么
还有一个就是我们要确保什么啊
你要确保当前这个增大这个问题
还有一个就是说再往下执行
它就有一个什么啊
他就执行这个v l node
是不是再往下面清除
执行它整个函数的一个核心点
对不对
但是我们在分配的过程中有任何问题啊
整体思路全部解决
解决之后
我就来看下一个问题
我们把它放大了
这东西研究了是不是好
那这个我们研究K之后
接着我们就来看下一个是不是
下一个就是说我们在设计的时候
它怎么进行调用
是不是我通过的图形
就是我们我们现在是不是通过什么来通过
这个好
通过视图
我们通过视图来表示什么
表示视图来表示v Mac他的一个什么分配的
一个什么分配的流程
我们来看一下
那么他这个分配流程是怎么做
是不是大家不要着急啊
因为我们在应用过
但是你要研究这个底层
还是需要这个过程是吧
那首先看第一个
第一个刚才我们讲了啊
刚才我们已经研究研究的差不多了
是不是已经讲解差不多
你看第一个啊
嗯对大小大小设为20
是首先我们看到这个内核源码执行哪一个range
就证明这个函数CTRLC
第一步VMC
首先第一步要调用的
首先它调用这个对不对
可以调用它啊
调用它之后
执行这个函数之后就会从哪里来
就从上一次我们在研究查找红黑树上
看一下进步的分配是从哪里来
就从这个地方开始了
是吧嗯
从什么
从我们上一次查找这个什么红黑树的结果
是不是专门有个什么一个叫做F
free free什么下划线
v map里面有一个什么catch
看到这个行函数当中进行什么
当到这个函数当中进行尝试操作
是不是就这么个意思啊
尝试那么尝试成功与失败
那具体要看这个问题
并不是说你尝试一定要成功
是不是你不尝试肯定是失败
尝试了还还有可能会成功
是不是不传的失败就往下走了
嗯说明操作过程中就说如果我们从上一次啊
如果是
那就可以找到这个VML它的大小
那如果不是
那就找不到
不是就从整个如果你不是
那就从这边开始了
注意啊
是这么一个
如果不是否是否的话
否则必须在执行开始看
如果是否
那么就又从头开始
否就从头开始
就是从头开始
那就从头开始
就有一个什么
就刚才讲了V啊
MACO下划线有一个什么呢
这个start没有开始什么开始遍历遍历搜索
嗯就这么个意思
那么如果是会怎么样设定会找到适合的东西
如果是
来这个是四啊四
那我们就查找什么呢
查找合适大小的一个什么大小的一个页面
就是v map下划线什么error就行
那么执行这个函数之后
再接着接着你要讲什么啊
你要通过一个函数插入到红黑树当中
他这个处理过程就是这样的
12800
好5000可以接着往下走
往下走
通过什么
通过这个下划线
v map里面什么error
这个是实现什么
实现插入这个红黑树啊
这个操作
你插红黑树就分配物理页面了
来放上去一点啊
嗯接着下一个下一个做什么呢
下一个就是说我们要是要分配什么
分配物理的一个什么页面
分配物理页面就直接通过这个了
log下划线配置这个函数去处理
那么还有什么
还有虚拟地址和物理地址之间
你要建立映射
否则就不行
他整个过程就是这样的
再往下面走啊
就落到这来了
嗯接着我们再往下
你在分配物理页的时候
他怎么做呢
物理很简单
处理完之后就通过这个map map
下划线VM里面去处理
但是我们为什么现在你是为这个v map error
是不是这个什么
它对应的一个虚拟地址和什么呢
和物理地址
物理就是物理页面了
物理页面直接直接进行创建
一个创建一个映射操作
就这么一个过程
所以他就从这边移到这来
他出来了
你创建完之后什么创建完之后
你要回这个地址了
你不就没法搞了
是不是啊
所以最后你要回嗯
最后我们要返回这个起始地址
你返回起始地址通过什么v map里面有个什么error
它的整体流程我们全部解决
OK你看全部搞定了
这就是为MC的一个分配的一个流程啊
啊各位朋友啊
如果大家是后面来的
没有跟上前面我所讲的没有关系是吧
大家可以什么可以找贝贝老师来领取
今天晚上那个视频笔记
是不是包括往期的一些相关资料
标注一下标注
方便阅读过程中看了看了看着没有眼眼
就是眼睛没有什么没有疲劳啊
换一下颜色
是不是再往下走
再往这边
嗯这个可能有点小是吧
嗯就这么干啊
就这过程
但是但是这个操作过程中找到适合的A
他这个页面从哪来
从这头这来
他就这么一个流程
整体思路啊
各位朋友整体思路
我们钱不给整好了
是不是
那这个思路整理好之后
我现在就将将到来找贝贝老师要就行了是吧
我就把这个提到下面来
就这么个流程画好了啊
啊这是这个视图来表示的
但是机体操作你可以看看
这个要把下面一个调用get
是不是返回啊
是不是node1步一步往往里面操作就可以了
往里面
一个页面内存页面是不是
那你要看他到底是多少位
要搞清楚
一个页面我们60注意啊
一个页面的大小我们是多少
是4KB4KB默认啊默认嗯
小谢这位同志啊
就是LINUX内核
就是LINUX这个什么内存
它一页是不是一的话
我们默认值默认为就是4KB
默认是4KB
是不是要搞清楚
这里提到又出了一个问题啊
就什么意思呢
就是LINUX它同时支持什么
同时支持这个正常大小的内存页啊
那么大内存也就是其实它有两个点
这个你从这个点去出发
你看啊我们在分配内存页
它是这么分配啊
你看
同时对不对
它支持什么支持正常的大小
那么一个是什么内存页
是不是还有个什么还是大内存页了
当内存也就这个了
就是后面会讲啊
hung hog page嗯
就这个
但是绝大多数啊
大多数在这个是大多数这个啊处理器的内存页
就是大多数这个处理器的内存页嗯
就是默认的成就
默认大小为什么大小为4KB
对不对
4KB啊
虽然啊虽然有部分的处理器它会使用什么
有的地方是八K六KB64
但是4KB的页面仍然是我们操作系统默认啊
默认这个页面配置的主流的核心点嗯
就除了正常这个页面大小之外
是不是就不同处理器它包含不同大小的页面
所以还有一个问题啊
大家还没注意
所以说什么问题呢
就是我们经常讲的一个什么X86
是不是
好X86这个处理器对不对
处理器啊它可以什么
它可以使用多少
使用两兆两兆的一个内存页
它就这么个思路
是不是那么一般我们讲这个4KB是历史啊
历史遗留过来的
是不是一直保存到现在
为什么
实际上现在啊
虽然现在我们对计算机的硬件啊提升的非常快
是不是
所以这一般都不考虑这个问题啊
这一般不考虑
所以说这个随机存储这个内存
所以4KB内存一的大小他不是最佳的选择
但是默认是4KB
就说什么意思呢
就是说8K或者16K
他也不也不一定说你8K16K
它是根号64大
最好是不是只是在这个环境做一个权衡操作
嗯就这么个意思啊
来存储分配是不是好
那现在我们就来看下一个问题了
是吧好
下一个问题我们就要研究
这是刚才讲的第一个V就出来了
要第三个了
下面第三个第三个第三个是什么呢
就是MELOO
这个我经常用的是MACO函数的一个分析
什么意思呢
就是当我们这个程序员使用这个函数
对不对
MC的它是什么
它是我们C程序当中对啊
这个C程序当中的一个什么内存分配函数
但是说假设啊假设你有两个进程
AB两个进程
那你通过两个函数啊来分配这个内存
是不是
但是MACO这个函数
它是C语言标准封装的一个核心点
所以说最终结果啊
最终结果是什么意思呢
就是说你他是怎么用的
大家注意啊
怎么用啊
你要挖掘是挖掘可以
那肯定可以挖掘好看啊
你足够大就没问题啊
你看这边什么意思呢
就说我们提到的这个
我们从C语言入门的时候就讲过了
就微妙的函数
它是什么
是C标准库进行封装的
C标准库封装那个什么核心架构
对不对
但是说他会做什么呢
就是C标准库它会做一些处理
是不是就是相当于什么
相当于它会调用调用什么
调用LINUX的一个什么系统调用接口
有个BRK就这么一个意思
大家不熟悉BK了
他BKBK就说我们不熟悉BK
就说原因在于什么
我们只用前面
是不是就不管一管到底是什么关系
但是bk它这个系统调用接口
是不是很少有人知道
那是因为什么会直接使用系统调用
通过他什么
即使这个地方他就是像什么
就是直接向系统申请内存
对不对
而且总是使用MACC之类的标准扣了
所以说啊BRK是不是
如果按照按照这个案例来讲的话
你看啊像这个MACA就相当于什么呢
就相当于我们零售商
那么这个BRT就代理商就这个意思
就是说MACC函数它是它为我们用户啊
这个进程呢维持一个本地小仓库
就这个意思啊
但是当进程需要更多
当进程需要更多内存的时候
他就会像个小仓库要货
是不是
那么当小仓库不足的情况下
他才会跑到后面那个什么BK
所以啊我举这个案例就是这个意思
就相当于我们新华
好比什么
好比这个零售零售商
是不是那个BK是比这个代理商就这个意思
是不是就是一般情况下你调这个函数的时候
是不是就能够满足我们啊普通的一个进程维护
专门做一个本
就是相当于本地的一个小仓库一样
是不是那么进程需要
如果进程需要更多内存的时候呢
它就像一个小仓库的一个代理商
是不是要货就可以了
是不是
那当这个小仓库
是不是当小仓库内存不足的时候
哎
他就通过什么
通过代理商
这个BK是不是向内核批发这个内存
就这个意思啊
思路
那么具体这个BIK内核
源码分析在哪个地方呢
好那现在我们进行进一步的研究
OK各位朋友算了
就到这来了啊
这是第二个是看不清楚
刚才有个朋友说看不清可以
差不多之后呢
我们找到这个页码里面
找到你要找mm内存管理
找到这个mm mm下面有个什么map
哪里有
这个map点C好出来好
map点是下面是不是就可以找到我要的
他专门有一个map是系统调用
系统调用CTRLFSS
你看BKB2K就掉这个函数
是不是这不就出来了
这个函数它有很多个
你不止这一个啊
你要搞清楚是不是系统调用的
这个定义是通过什么
通过这个SSCODEFILE1这个航母来实现的
是不是
但是他具体操作它可以有一些相关的头文件啊
让我们进行什么来进行去完成啊
这点我们这点的话
我们就不需要操心是不是不加字
不需要操心这些相关的问题
那么B2K的话
比如他有arm64啊
有各种各样的啊
就这个了
你需要向内核里面申请
就通过这个来啊
就这么一个函数
看到没有
通过这个函数实现好
那么他也可以什么呢
他也可以进行进一步的展开
进一步的去实现
嗯BK是不是里面的参数相关进行进一步操作
所以后面就出现什么
在出现调过程
它有2M64
是不是
也许你不上六十九三十二位
它也会出现这一块
你看你在哪里找啊
我们在什么
在刚刚我们看到的
你看你在ARCH里面
一般我们以这个为准啊
这个方便是吧
include a s m下面这个扩
SYS库
看看这个双击这个看到没有
一路翻下
我叫大家都一样好看
这地方
那这里面有哪些呢
你看啊
你看第一个是对应的
你看comps s cordefile
123456是吧
但是这里面有什么arm6是对应的名称吗
井号没有
那就通过这个来联系吗
后面有很多你发现没有
你看arm64S五S里面有个什么
这两个name是不是传name之后
那这d s vs你这个名字写什么就是什么吗
对不对啊
代替这一块
一直一直走到下面那个do s y s
这都是什么
都是BT实例吗
所以我们在放的时候
你看他怎么去放呢
你看这个SSBRKCTRLFFCTRLF的下划线
等一下啊
我两个下划线下线什么呢
do下划线SOS不就出来了
是不是
SS下划线后面他就可以
什么要跟着你这个下划线有个BK是不是啊
BK系统调用手写
是不是
那这就是我们现在所看到的这部分
移到很多是吧
那这个就搞定了是吧好
那么这个搞定之后
接着看后面后面的话我们还知道什么
就是我们作为一个工程师
是不是
那么最基本的话有一个问题是什么呢
就是说根据刚才所说的
那么必须要知道接下来就必须知道什么
你必须要知道下面第四个问题
第四个问题是什么
第四个问题就是用户态的地址
空间的一个什么布局啊
布局怎么布局
但是要知道啊
就是比如说我们在什么呢
你在32位的
你在32位LINUX内核当中
对不对
就是你每一个每一个用户进程
每个用户进程它拥有什么
拥有3GB的一个什么应付它的一个虚拟空间
而且如果我们在什么
而且我们在64位就不一样了
你在64位LINUX内核当中当中
对不对
就是每个进程它可以什么
可以拥有多少256T
256tb的
一个什么tb的一个用户态虚拟空间
这两个是不一样的啊
那32位只有三个基地
还有1GB还有1G比这个内核啊
这个也要根据这个来
是不是
所以说这些虚拟空间他们是如何进行划分
这个问题一定要搞清楚这一点
有个问题
这是基础课程
等下给你回答啊
OK好那现在来看就是这个用户态的空间布局
那么这个用户就是用户进程的一个可执行文件
一般是这样的
用户进程
用户进程的可执行文件它是什么
它是有数据和代码段进行组成的
所以说我们这个数据段嗯
它又包括什么
包括所有的一个什么静态分配的
一个什么数据空间
是不是数据空间有哪些啊
你比前几变量和静态局变量是不是
但是在在执行文件加载的时候
内核空间就为它分配好了
它包括这个虚拟地址和物理页面
所以他们之间可以建立一个关系
是不是可以关机体
是不是就是他的一个具体操作怎么去完成是吧
机体机体的什么机体
我们这个arm64架构架构
架构他这个他这个就是处理器处理器架构
他进程地址空间的一个什么布局
嗯如下
我们来看一下哪一些呢
我画一个图形
一般描述的256内存空间
空间256G完全足够了
是不是还有一些非规范区域不能用的
是不是
那就把这个搞出来了
把这个拿出来嗯
这一块是不是
嗯这个啊
再往后面再给你来一个
发小填充颜色更改一下啊
这个是非规划区域
是不是非
然后再还有什么还有一些相关的用户账啊
还有一个是用户账
还有什么IMAP啊等等
用户站用户站
用户空间
用户账
用户在下面再给你来一个就是IMAP的空间
啊这个是imap map空间
在这里还有堆空间是吧
除了IMAP空间
还有一个是堆的空间
再画一个D空间
堆的空间
好堆空间
再往后面我再画几个就不再画了
还有对应的什么
比如我们所讲的数据大数据大
嗯除了数据端
还有代码端
代码大呢
还有相关对应的一个什么啊
没有经常使用的
我们叫做什么叫做保留区
是不是还保留区好
那现在的话这些保留期我们一旦搞定之后
是不是下一步你要做的是什么
下一步就是要把它分归纳起来
是不是你没有把它归纳起来的话
你就不知道怎么回事
就他的布局是怎么样的是吧
我把这个列出来啊
大家来看一下算
那部分就出来了
我们怎么去分
是不是
那我通过这个方括号是不是最上面那个位置
这下面我们是arm64架构
是arm64
我们是arm64架构
arm64架构
那么这个地方必定是
刚才我们讲了一个什么内核空间
内核空间就是256tb
是不是完全足够了
就是这个还有什么呢
除此以外
下面这个部分是非规划区域
嗯这是不规范的区域啊
要注意啊
哎这地方是非规范区域
那么非规划区域
再往下面就是我们所讲的用户空间来应付
就往下走了
应付空间
看到这儿来应付工钱啊
用户空间它也是256TP
但是gt里面哪一个哪一方开始
比如你刚才的BIK是不是v maco map
是不是他怎么用最上面这块地址
等一下啊
这上面这一块
等一下啊
这这这不对吧
这上面啊
最上面这个地方的地址是0X多少
相当于16个F12341234
12341234
就从地方开始
20
那怎么分呢
就0XFFF后面有多少有12个零
哎不对啊
三个01231234是吧
他是这么分的啊
可以啊
这样分好之后呢
再往下面那中间这一块是不是中间这一块
下面这一块
比如你从这个非规范歧义
那你不规范区域的这一块要搞清楚
你不规范这个区域
那么非规划区域那就不能用
不能用的话
再往下就是用户对用户这个地址开始
按这个算的好
我们用这个
它是零零开始的
几个零四个零是由这个乘除开始
那么从这个什么呢
我们从这个用户账对不对
到什么来到这一部分
你看啊编成这个指针
下面这个部分就是我们所讲的map
IMAP的一个什么IMAP的一个空间
没有IMAP空间
IMAP空间
那你这个箭头就朝下了
IMAP空间啊
你这个经验头
你刚好顶到这个位置
这根线刚好接着下面呢堆在这里
堆在这个位置
所以他在设计的时候
是不是下面就有一个IMAP
看到没有
专门有个m map消化线
就刚好接到这来
刚接到这个部分
那么他接到之后堆空间是往上走
所以他有BK
这个不行
bonk在这里
start下划线bk
嗯它两者的关系
一直顶到这个EMBS这来啊
看下面这里
好从这个用户站到下面这一部分啊
到下面那个什么到下面那个对空间之间
它都是对空间要搞清楚啊
i map它也是对空间
是不是你对空间本身用户在也在对空间范围内
所以我们在设计的时候就这么一个流程看
从这个地方开始是吧
一直到下面这样来
我把它拉下来一点啊
好从这边到这个不好表示是吧
等会下走
开玩笑
是不是
来搞大一点
可应该差不多了是吧
嗯可以再接到这个地方来
嗯这边
好没问题了是吧
全部做好了
这是什么
这是2M6
就这样划分
但是具体是多少
是不是
那我们在设计过程
就说他这个指定虚拟地址空间的顶部
是不是顶部向下延伸
所以B站这个思路
这个过程大家来看一下
是这个部分叫做堆空间是吧
两边
就这么个思路
两边箭头啊
OK再从地方到这来
算了就不画了啊
反正你知道这一块都称为什么
独立空间就可以了
好那么现在我们了解啊
了解这个堆空间之后
是不是现在我们就看下一个问题了
是不是那个问题的话
就针对这部分进行进一步的分析是吧
要注意啊
OK好段页式啊
你要注意点什么意思
但是呢它这个结构是这样的
但是这个管理系统的基本原理
就说首先他先将什么呢
先将用户程序分成很多很多个段
再把每一个单分成很多若干个页
并且每个蛋就附一个段名
是不是就这么意思了
就说你在什么
就是我们在氮液式系统当中
就说那么他那个地址结构有段号啊
啊大内页号啊
或者是业内的地址啊
三个部分组成
就是你这个小周的
这这这位这位这位这位朋友是吧
你所提出这个问题的
你有时间你可以研究一下
是不是研究进行进一步研究啊
这就给大家发好了
OK那我们接着来看这个问题
针对这些信息
我们进步的划分是不是一步一步往下走
这样的话你就了解的更多是
那现在我们就来看下一个
下一个下一个是什么呢
刚刚所提到的啊
比如我们这个BRK是吧
你BRK分配的空间是从什么
是从这个数据的一个顶部
对不对
就是N的数据段的结束啊
N的d and date是什么意思呢
这个行星啊啊啊啊
BRK分配是从数据到顶部这个end date啊
到什么到我们用户账的一个底部
他的思路是这样的
就是说我们所有什么呢
就是我们所有的这个动态分配空间
它是从进程的一个什么
从进程的N的数据单结束这个地方开始
就是你每一次每一次分配一块一块空间
对不对
但是他就是把什么就是把这个这个边界
把那个边界地址往上面进行
进一步的什么来推进一个段
往上面推啊
往上面推进一段
就这个意思
同时啊同时内核和这个进程呢
它都会什么都会记录
我们这个什么当前的一个边界地址就这么干
所以说我们在源码里面装了一个task什么
他是个下划线
它有个size
是不是他是size大小
它给我们处理器架构跟这个处理器架构
它所支持的一个什么最大虚拟地址
嗯最大虚拟地址的一个位宽
位宽有关
哎位宽啊
位宽有关
一般是以四十八四十八位的那位
48位宽的话
它是怎么设计呢
就在这48位宽
具体你要查看查看内核的页码啊
那你看从这里开始
他这么做的
是找到这边来是吧
那这里面有一个什么呀
嗯ARCH下面有个什么arm64是吧
include a s m里面什么process
就看到没有
如果是32
有32的话
就是32嘛
你不是32
64
64
64大结
在我们这个地方
Task size size64
还有一个task size
64
64不是64
就是32
32
不是从开始
那就是0X1
后面几个零呢
1234567是吧
七八根
那现在我们就从这个地方开始
你看这个结构会看这个结构就可以了
一个68行
这地方六十四三十二所定义这个部分看到没有
这地方是个红点进行判断
你到底30还是64
是不是
好在这个位置OK好
那现在啊这个我们就解决了
是不是
好这个行星的这位啊
这位同志是吧
嗯GDT和DT指的是什么哈哈其实这个问题啊
你要注意啊
这个问题是这么这么一回事是吧
既然我看到了
就给大家打一下
算我们所讲的跟跟什么
跟刚才这位朋友这个蛋液是就是断了这个地方
它有一定的关系
是不是那么什么意思呢
就是分段机制就是在操作系统里面啊
在从系统里面的话呢
它这个分段机制跟我们这个GDT跟LDT
它有一定的关系
怎么回事
那现在我们进一步观察
比如断了
比如CPU里面CPU里面它有什么呢
有这个页的部件和断的部件是不是
所以说一般情况下
你比如这个32位的保护模式
它每个任务都有四个GB的虚拟地址空间
它就像一个什么呢
就像一段平啊
就像当什么平直的线段
就是叫什么
放这一块是不是线性地址
但是这个段它就不一样了
段它是实现什么段
它是实现这个地址
实现虚拟地址到现行地址转换
的一个机制的一个啊基础
那么在保护模式下
这个段呢
比如断机子
但限制的长度是不是还有一个什么
还有一个就是断了一个什么段了
属性对不对
所以他再往下面翻
对不对啊
那你再往下面分的话
那么接着呢接着你但有一些相关限制
但限制一般是20位表示不就足够了
按C表示的话
以大大的界限
那么自己就相当于什么
以4KB啊
刚才讲了4KB为单位了
你从零开始递增是不是就可以了啊
还有什么呢
还有就给我们提到了啊
还有就是你提到这个问题了啊
什么意思呢
就是它有一个什么有个段
对不对
就是有一种就是段描述符
段描述符
这个表他和蛋蛋一个什么
有八个字节有定的关系
就是你这个它在操作过程当中
每个段它都有一个描述符
他是为了存放这些描述符
需要在内存当中给他开辟出一段空间
那么这段空间里面所有的描述符
都把它堆到一块啊
集中放到一起
这样的话就构成一个描述符表
对不对
那么描述表的长度它可以发生变化
就说你最多可以包含8KB这个描述符表
是不是为什么呢
因为端的选择它是16位啊
比如还有13位作为index使用了
所以后面他有什么有两种
就是相当于什么相当于有两种的这个描述符表
哪两种啊
就是你提到了这个小周的这位大佬
这位朋友啊
就是这不是行星还是行星
什么时候叫什么是GDT和什么和LDT
就是你提的这个问题
这个问题就出来了
是不是
那么它这个结构是不是那么LDT啊
跟我们当中提到什么GDT差不多
是这个区别在于什么
在于在全局和局部操作
就说LDT这个表它是存放在什么
存放在LDT类型段中间
所以说你GDT它必须包含LDT的一个
什么段描述
就是LDT它本身就是个段
是不是GDP
不是你要搞清楚啊
GDT它不是不是段LDT它本身是个段
就说我们在LDT这个段当中啊
就是它的线性中这个基地址
你我们就需要借助什么
需要借助这个GDGDTR
查找ITT相应的地址
所以说需要什么呢
需要的是gt的那个断流才能解决问题
否则解决不了
他就这么个意思
所以它的描述方式区别在于全集合局部这一块
所以说后面我就给大家总结计划
是不是就是LLDT它本身是一个什么
本身是一个段
是不是
但是R什么GDT他不是
是不是
那么比如我们查找什么
你查找GDT啊
在什么呢
在现行这个在现行地址当中的一个什么基地址
是不是这时候就需要什么基基地
基地需要什么需要的GDTR
对不对
先gt r
然后什么呢
而且我们在
而且你在这个请查找
在查找LDT这个相应的一个LDT
相应的一个基地址
他就需要什么
需要的是JDT当中的一个
什么段的一个描述符
大家可以
其实如果你真的要去研究这两个的话
一下子可能摸不清楚啊
如果你要去研究建议啊
建议大家看一下什么呢
看一下操作系统里面的一个什么实模式
和什么呢和保护模式里面就会提到
你把这个干一下就可以了
把这个研究就可以
那么对于操作系统来讲
每个系统必须有一个GDT
为什么用它
他就是系统当中所有任务啊
和这个程序是不是就这么个意思
你要搞清楚啊
就是相当于什么
相当于什么操作系统嗯
对操作系统来讲
每一个系统它必须要定一个什么
定一个GDT是吧
但是用用它干什么呢
用于系统当中的什么所有的任务
所有任务和程序啊
那也可以什么呢
我们可以选择性的定义定义什么
很多个这个什么LDT是不是刚才讲了啊
L啊就GDT它本身是一个端
而且线性地址空间的一个数据结构
那么GDT的一个什么线性G地址和长度
它必须加载到gt t r里面去
所以说因为每一个
因为每个描述符的长度是八个嘛
所以GDC的那个基地址啊
最好跟八个字节进行对齐啊
这个就是跟就是为什么如果如果各位朋友啊
就说为什么听这个比较模糊的概念
搞不清
那大家建议大家研究一下操作系统
这跟潮汐有关系
是不是
OK你如果你在研究的话
比如当选择符刚刚才讲的八弦字符是什么呢
就是比较复杂
是复杂
小谢
这就说比如我们实事就是你实模式下那个
比如六个六个端机程序
你要你要把它搞清楚
比如cs d s e s f s d s s s
对不对
就这些就是在保护模式下
它叫做端选择器
那么实时模式它不同的就是你保护模式的内存
访问它有它自己的方式
但是在保护模式下
我们访问内存内存的时候也需要指定一个段
是不是
那么把它传送到什么传送段
选择性内容
它不是逻辑地址
而是断描述符的一个什么
描述符表当中的一个索引号
所以在保护模式下
你访问一个访问一个端的时候
那么传送到端选择器的时候
这个段选择符
比如说我们选择什么
选择这个操作
比如我们刚刚讲了
刚刚提到是不是
所以说他有什么有16位的
是不是等等啊
这个我们就不再扯了
越扯越远了
是不是啊
就这个问题啊
好那现在的话我们就回到课堂里来
回到课堂里来
那我们回到课堂的话
我们就再往后面看一下
那怎么做呢
我们观察一下啊
在哪里呢
在这个map点C没有
在map点C
map点C里面就有一个叫做
有一个
叫做IMAP下划线
Sm
没有BKB下面看他指的地方
就是mm所指向MFSEC是不是他做什么
就是申请学者类型的一个什么
读写信号量这一部分的操作
因为什么
因为后面你要修改进程的地址空间
所以你必须这么做
所以到这里的时候
我们这里有一个BK
那么这个成员是专门记录什么
专门记录这个动态分配区的一个什么
当前底部
那他也有什么进程进程的内存描述
里面也有个B动态在哪个地方
在这里面来了
在
你看在这个include linux上面的mm TP
刚才知道的B2K
BKSTUBK就可以找到它了啊
start这个看到没有
这个我上次也给抢过了
看到没有
你看这个什么BKBK嘛
就代表什么
代表堆的一个什么对的
起始地址保存在这个地方
是不是BK表示当前区的地址呢
就这个意思是吧
这就解决了这些问题
解决后来查找相关的
就是我们对那个MC的函数的调用是不是
但是我们必须要了解一个问题
这个BRKLINUX内核
这个BIK系统调用那个流程怎么执行
你怎么跑这来了是吧
没关系是吧
这是第四个
第五个
第五个第五个是什么呀
第五个就是
好LINUX内核是吧
这个什么BK系统调用的一个流程视图
来看一下啊
发一个图形
它怎么去调用呢
大家注意嗯
首先第一步是吧
首先第一步一步一步来嘛是吧
首先第一步第一步做什么
第一步就通过是吧
通过BK这个系统调用请求什么
请求新的一个
就会调用调用什么
调用下划线SYSBK
第二步了是吧
啊这第二步第三步是吧
好第三步他就走这来了
第三步
如果啊嗯如果什么呢
如果我们这个BRT它小于什么
小于MM这个指针所指向的BK怎么办呢
就说明什么
说明进程请求
说明进程这个请求
他就这么一个思路就出来了
是不是好
这是我们第三步是吧
好第四步的话
那就调什么插入黄黑树了
是第四步就走掉了
第四步
第四步就调用调用什么来调用这个insert下划线
这个v map里面的error插入插入到红黑树
就这个就这么走过来
走过来之后
接着就要检查了
你要检查边界bk是否有现成的虚拟内存区
有直接干扰
是不是
接下来那就检查检查新边界的一个什么
bk two是否有什么有现成的一个什么有现成的
现成的一个什么W啊
就是VM虚拟内存区
看它有没有
是不是
Ok
然后再到这边来
是不是
好到这了之后
你看到这一块的话
他做什么呢
那么你检查这个边界
是在通过通过这个A偏函数
是通过get下划线
这个u on map下划线这个error干什么呢
查找一个可以使用的什么
使用的一个线性地址啊
它的一个区间是不是就这么个流程
好信息地址信息流程之后再进行
如果有的话
就可以合并
有的话我们就往下走了
就通过这个通过通过什么来
通过VMA里面这个进行什么检查
是否可以和现有的VMA进行进一步的合并
嗯就这个意思
然后你合并是不是合并之后呢
比如新的一个产生呢
是不是就这么一个思路
就这个啊到这来到这就是新的什么呢
你直接现在我们创建一个什么
创建一个WVMA
并且要填充什么
填充不买就可以了
然后再把它添加到红黑树里面去了
他也是这么个流程
并不是想象中复杂
再往下走
看到没有
下面就通过什么
通过一个函数
这个link是不是干什么呀
直接把什么把这个v ma添加到这个进程
红黑树是不是
然后再返回一个地址
走到这最后返回虚拟内存区域
返回v ma的一个起始地址
OK是吧
就这么多整体思路啊
整体思路我们现在全部都给大家讲解完毕了
是不是有问题啊
我们可以通过这个QQ啊
跟我进行进一步的沟通与交流
属于今天晚上的课程
那我就给大家分享到这里
所以我们现在通过这个图形
嗯就这个啊
这个是不是
那么通过这个图形
就是进程使用m lock系统调用的时候
就麦克这个系统调用的时候
那么就会调用出来i m popular
然后分配物理内存
并且建立映射
再通过用户程序很少使用一个VVM
什么呢
这个logo的分配这个掩码
所以说BRK这个系统不会为这个用户进程
马上分配一个什么物理页面
而是一直延迟到什么呢
用户进程需要访问这块虚拟地址空间的页面
发生什么
但是发生缺页中断才会去分配物理内存
并且和这个虚拟弟子之间建立一个映射关系啊
这个后面啊我们再进行进一步研究
那么今晚这个课程啊
我就给各位朋友
各位大佬们就分享到这里
我们下一次课再继续啊
你感觉这个管理多个进程半秒数
那肯定更加复杂
那不是一般的复杂啊
是相当复杂
比如进程调度是不是啊
比如进程管理调度这一块
是不是内存管理这一块等等啊
文件系统都比较多
OK好
所以今晚我们讲到这里了
各位朋友啊
再见下一次课玩

## 参考

[Linux内核《系统调用(vmallocmallocmmap)》_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1xi421o73f/?p=8&vd_source=4a018e55005b433dc9d72a8e969a1c5f)